{
  parserClass="com.jsonnetplugin.parser.JsonnetParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Jsonnet"
  psiImplClassSuffix="Impl"
  psiPackage="com.jsonnetplugin.psi"
  psiImplPackage="com.jsonnetlugin.psi.impl"

  elementTypeHolderClass="com.jsonnetplugin.psi.JsonnetTypes"
  elementTypeClass="com.jsonnetplugin.psi.JsonnetElementType"
  tokenTypeClass="com.jsonnetplugin.psi.JsonnetTokenType"

  tokens = [
    L_CURLY='{'
    R_CURLY='}'
    L_BRACKET='['
    R_BRACKET=']'

    COMMA=','
    COLON=':'
    LINE_COMMENT='regexp://.*'
    // "/*" ([^*]|\*+[^*/])* (\*+"/")?
    BLOCK_COMMENT='regexp:/\*([^*]|\*+[^*/])*(\*+/)?'
    // else /\*(?:[^*]|\*[^/])*\*+/

    // unclosed string literal matches till the line's end
    // any escape sequences included, illegal escapes are indicated by SyntaxHighlighter
    // and JsonStringLiteralAnnotator
    DOUBLE_QUOTED_STRING="regexp:\"([^\\\"\r\n]|\\[^\r\n])*\"?"
    SINGLE_QUOTED_STRING="regexp:'([^\\\'\r\n]|\\[^\r\n])*'?"
      STRING='regexp:"([^\\"\r\n]|\\([\\"/bfnrt]|u[a-fA-F0-9]{4}))*"?'

    NUMBER='regexp:-?(0|[1-9]\d*)(\.\d+)?([eE][+-]?\d*)?'
    TRUE='true'
    FALSE='false'
    NULL='null'
    IMPORT='import'
    // Actually not defined in RFC 4627, but may be used for JSON5 and helps with
    // auto completion of keywords. Semantically, it represents "bad word" type
    // of tokens
    // Could be as loose as [^\s\[\]{}:,\"\']+, but is slightly more restricted
    // for the time being to match most forms of npm package names and semver versions
    // in package.json.
    // See https://github.com/npm/validate-npm-package-name
    IDENTIFIER="regexp:[[:jletterdigit:]~!()*\-./@\^<>=]+"
  ]

}

//jsonnetFile ::= item_*
//
//private item_ ::= (property|COMMENT|CRLF)
//
//property ::= (KEY? SEPARATOR VALUE?) | KEY


root ::= expr
expr ::= expr0 select* slice* slice2* apply* binsuffix* objextend* insuper*
select ::= "." IDENTIFIER
slice ::= "[" expr ( ":" ( expr ( ":" ( expr )? )? )? )? "]"
slice2 ::= "[" ":" ( expr ( ":" ( expr )? )? )? "]"
apply ::= "(" ( args )? ")"
binsuffix ::= binaryop expr
objextend ::= "{" objinside "}"
insuper ::= "in" "super"
expr0 ::=	"null" | "true" | "false" | self | dollar | DOUBLE_QUOTED_STRING | NUMBER
|	"{" objinside "}"
|	"[" (expr ("," expr)* ","?)? "]"
|	"[" expr ","? forspec compspec "]"
//|	expr "." IDENTIFIER
//|	expr "[" expr ( ":" ( expr ( ":" ( expr )? )? )? )? "]"
//|	expr "[" ":" ( expr ( ":" ( expr )? )? )? "]"
|	"super" "." IDENTIFIER
|	"super" "[" expr "]"
//|	expr "(" ( args )? ")"
|	"local" bind ( "," bind )* ";" expr
|	"if" expr "then" expr ( "else" expr )?
//|	expr binaryop expr
|	unaryop expr
//|	expr "{" objinside "}"
|	"function" "(" ( params )? ")" expr
|	assert ";" expr
|	"import" DOUBLE_QUOTED_STRING
|	"importstr" DOUBLE_QUOTED_STRING
|	"error" expr
//|	expr "in" "super"
|	IDENTIFIER

self ::= "self"
dollar ::= "$"

objinside	::=	member ( "," member )* ( "," )?
|	( objlocal "," )* "[" expr "]" ":" expr ( ( "," objlocal )* ( "," )? )? forspec compspec

member	::=	objlocal | assert | field

field ::=	fieldname ( "+" )? h expr
|	fieldname "(" ( params )* ")" h expr

h ::=	":" | "::" | ":::"
objlocal	::=	"local" bind
compspec ::=	( forspec | ifspec )*
forspec	::=	"for" IDENTIFIER "in" expr
ifspec	::=	"if" expr
fieldname	::=	IDENTIFIER | DOUBLE_QUOTED_STRING | "[" expr "]"
assert	::=	"assert" expr ( ":" expr )?
bind ::=	IDENTIFIER "=" expr
|	IDENTIFIER "(" ( params )? ")" "=" expr
args	::=	expr ( "," expr )* ( "," IDENTIFIER "=" expr )* ( "," )?
|	IDENTIFIER "=" expr ( "," IDENTIFIER "=" expr )* ( "," )?
params	::=	IDENTIFIER ( "," IDENTIFIER )* ( "," IDENTIFIER "=" expr )* ( "," )?
|	IDENTIFIER "=" expr ( "," IDENTIFIER "=" expr )? ( "," )?
binaryop	::=	"*" | "/" | "%" | "+" | "-" | "<<" | ">>" | "<" | "<=" | ">" | ">=" | "==" | "!=" | "in" | "&" | "^" | "|" | "&&" | "||"
unaryop	::=	"-" | "+" | "!" | "~"